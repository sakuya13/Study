import Data.List
import Data.Char (toLower)

-- P1: find the last element of a list
myLast :: [a] -> a
myLast [] = error "empty list"
myLast [x] = x
myLast (_:xs) = myLast xs

myLast' = head . reverse

myLast'' :: [a] -> a
myLast'' = foldr1 (const id)

myLast''' :: Foldable t => t a -> a
myLast''' = foldr1 (flip const)

myLast'''' :: Foldable t => t a -> a
myLast'''' = foldl1 (const id)

-- myLast'' = foldr1 (const id)

-- P2: find the last but one element of a list
myButLast :: [a] -> a
myButLast [] = error "empty list"
myButLast (x:y:[]) = x
myButLast (x:y:ys) = myButLast (y:ys)

myButLast' [x,_] = x
myButLast' (_:xs) = myButLast' xs

myButLast'' = last . init

myButLast''' =  head . tail . reverse

myButLast'''' = head . reverse . init

-- P3: find the K'th element of a list, the first element is number 1.
elementAt :: [a] -> Int -> a
--elementAt [] _ = error "no element"
elementAt xs n 
    | n > 0 && n <= (length xs) = last $ take n xs
    | otherwise = error "out of index range"

-- P4: find the number of element of a list (length).
myLength :: [a] -> Int
myLength = foldr ((+) . const 1) 0

-- P5: reverse a list.
myReverse :: [a] -> [a]
myReverse = foldl (flip (:)) []

myReverse' :: [a] -> [a]
myReverse' [] = []
myReverse' (x:xs) = myReverse' xs ++ [x]

myReverse'' :: [a] -> [a]
myReverse'' xs = foldr (\x fId empty -> fId (x : empty)) id xs []

-- P6: whether is palindrome.
isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome xs = xs == reverse xs

-- P7:Transform a list, possibly holding lists as elements 
-- into a `flat' list by replacing each list with its elements (recursively). 
data NestedList a = Elem a | List [NestedList a]

flatten :: NestedList a -> [a]
flatten (Elem x) = [x]
flatten (List (x:xs)) = flatten x ++ flatten (List xs)
flatten (List []) = []

-- P8: (**) Eliminate consecutive duplicates of list elements.
compress :: (Eq a) => [a] -> [a]
compress [x] = [x]
compress (x:ys@(y:_))
    | x == y    = compress (ys)
    | otherwise = [x] ++ compress (ys)

-- P9: pack consecutive duplicates of list elements into sublists.
-- If a list contains repeated elements they should be placed in
-- separate sublists.
--pack :: (Eq a) => [a] -> [[a]]
--pack [x] = [[x]]
----pack xs = (x:first):pack rest
--pack (x:ys@(y:_))
--    | x == y    = [x,y]:pack ys
--    | otherwise = pack ys
-- this is implemented as group in prelude
pack :: (Eq a) => [a] -> [[a]]
pack [] = []
pack xs@(x:_) = first : pack rest
    where (first,rest) = span (==x) xs

 -- P10 (*) Run-length encoding of a list.
encode :: (Eq a) => [a] -> [(Int,a)]
encode [] = []
encode xs@(x:_) = (n,e) : encode rest
    where (first,rest) = span (==x) xs
          n = length first
          e = x

-- using lambda, point free style, must use type signiture
encode' :: (Eq a) => [a] -> [(Int,a)]
encode' = map (\x -> (length x, head x)) . group

-- using list comprehension
encode'' xs = [ (length x, head x) | x <- group xs ]

-- p11 (*) Modified run-length encoding
data Items a = Single a | Multiple Int a
               deriving Show


encodeModified :: (Eq a) => [a] -> [Items a]
encodeModified [] = []
encodeModified xs@(x:_)
    | n == 1    = Single x : encodeModified rest
    | otherwise = Multiple n x : encodeModified rest
    where (first,rest) = span (==x) xs
          n = length first

encodeModified' :: (Eq a) => [a] -> [Items a]
encodeModified' = 
    (map (\ys -> case ys of
                    [y] -> Single y
                    _   -> Multiple (length ys) (head ys)
         ) ) . group

-- cat comes in!!!
catSays :: IO ()
catSays = do
    who <- getLine
    case map toLower who of
        "cat" -> putStrLn $ who ++ " is cute!"
        _     -> do 
                    putStrLn $ who ++ " is fat"
                    putStrLn $ "beat " ++ who ++ "!"

-- P12 (**) Decode a run-length encoded list.
decodeModified :: [Items a] -> [a]
decodeModified [] = []
decodeModified ((Single x):ys) = x : decodeModified ys
decodeModified ((Multiple n x):ys) = replicate n x ++ decodeModified ys

-- using concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
decodeModified' :: [Items a] -> [a]
decodeModified' = concatMap helper
    where helper (Single x) = [x]
          helper (Multiple n x) = replicate n x

-- p13 

-- p14 (*) Duplicate the elements of a list.
dupli :: [a] -> [a]
dupli [] = []
dupli (x:xs) = x:x:dupli xs

dupli' :: [a] -> [a]
dupli' list = concat [ [x,x] | x <- list ]

dupli'' :: [a] -> [a]
dupli'' = concatMap (\x -> [x,x])

-- p15 (**) Replicate the elements of a list a given number of times.
repli :: [a] -> Int -> [a]
repli xs n = concatMap (replicate n) xs

-- pointfree
repli' :: [a] -> Int -> [a]
repli' = flip $ concatMap . replicate
--repli' = concatMap . (flip replicate)

-- p16 (**) Drop every N'th element from a list.
dropEvery :: (Eq a) => [a] -> Int -> [a]
dropEvery list n = list \\ (dropEvery' list n 1)
    where dropEvery' (x:xs) n count 
            | count `mod` n == 0 = x:dropEvery' xs n (count+1)
            | otherwise          = dropEvery' xs n (count+1)
          dropEvery' [] _ _ = []


-- (*) Split a list into two parts; the length of the first part is given.
split :: [a] -> Int -> [[a]]
split [] _ = []
split xs n = [take n xs, drop n xs]

split' :: (Eq a) => [a] -> Int -> [[a]]
split' [] _ = []
split' list n = helper list n 1
    where helper (x:xs) n count
            | count >= length list = [list,[]]
            | count == n = [first,rest]
            | otherwise    = helper xs n (count+1)
            where (first,rest) = break (==x) list














